/*
   Code for the Arduino Mega to be used with the Go-Bot cart. The Mega will be contained in the back of the cart which will contain -

   Arduino Mega mounted to a PCB.
   Pololu G2 High-Power Motor Driver 24v21 for the seat motors.
   Sabertooth 2x32 Motor Controller for the cart motors.
   A joystick jack to allow for analog or digital joysticks to be connected to override the front controller.
   Button to turn on and off the system.
   Power system to control power levels on startup and during runtime.

   This code will collect all data sent by the Arduino Nano and use that data to control the cart unless parental override is active.

   By: Andrew Gates, Reagan Stovall and Jesse Wiklanski in conjunction with Robert Gutmann.
   For: Mary Bridge Children's Therapy Unit at Good Samaritan Hospital.
*/

#include <Sabertooth.h>
#include <SabertoothSimplified.h>
#include <Wire.h>
#include <ArduinoNunchuk.h>
#include <TimerThree.h>
#define BAUDRATE 19200
#define INT_POS = 2047;     // Positive bounds for motor controller.
#define INT_NEG = -2047;    // Negative bounds for motor controller.

ArduinoNunchuk nunchuk = ArduinoNunchuk();

//-------------------- Joystick Data --------------------------//
const int SIZE = 14;
int myFrontArray[SIZE];
int myAtariArray[SIZE];
int myWiiArray[SIZE];
bool isWii;

//-------------------- Power Data --------------------------//
int buttonTurnOnOff = 13;
int systemStartPin = 8;
int PowerStrengthPin = 7;
bool seatInactive = false;
bool driveInactive = false;
int inactiveCounter = 0;
unsigned long loopTime = 0;

//--------------------- Seat Data -------------------------//
int motorControlPWM = 9;
int motorControlDIR = 10;
int seatLimitSwitch = 11;

//-------------------- Cart Data --------------------------//
int driveVal = 0;     // pos = forward, neg = back
int turnVal = 0;      // pos = right, neg = left
float speedD;         // 1.0 = FULL SPEED
bool killSwitch;      // button on the parental controls to stall the motor
byte stopVal = 0;
bool atariActive = false;
int BatPin = A0;
int batteryLevel = 0;

//-------------------- Signal Data --------------------------//
const bool DEBUG = true;
int analogZeroCheck = 0;
int potZeroCheck = 0;
int digitalZeroCheck = 0;
int seatZeroCheck = 0;
int oldCount = 0;
int sameCount = 0;
int initialStartCount = 0;

void setup()
{
  Timer3.initialize(10000000);    // Timer to initialize for inactive turn off.

  pinMode(systemStartPin, OUTPUT);
  digitalWrite(systemStartPin, HIGH);

  //-------------------- Pin Setup --------------------------//
  // Atari hookups
  pinMode(2, INPUT_PULLUP);
  pinMode(3, INPUT_PULLUP);
  pinMode(4, INPUT_PULLUP);
  pinMode(5, INPUT_PULLUP);
  pinMode(6, INPUT_PULLUP);

  // Pwr
  pinMode(buttonTurnOnOff, INPUT_PULLUP);
  pinMode(PowerStrengthPin, OUTPUT);
  
  // Seat Motor
  pinMode(motorControlPWM, OUTPUT); // input a
  pinMode(motorControlDIR, OUTPUT); // input b
  pinMode(seatLimitSwitch, INPUT_PULLUP);

  //-------------------- Timing Setup --------------------------//
  Serial1.begin(9600);             // For Sabertooth
  Serial3.begin(19200);            // The Max that the Nano can transmit
  Serial.begin(115200);

  Serial1.print("MD: ");
  Serial1.print(0);
  Serial1.print("\r\n");

  Serial1.print("MT: ");
  Serial1.print(0);
  Serial1.print("\r\n");

  //-------------------- Boolean/Declarations --------------------------//
  isWii = false;      // is Wii plugged in?
  killSwitch = false; // stalls motor
  driveVal = 0;       // pos = forward, neg = back
  turnVal = 0;        // pos = right, neg = left
  speedD = 1.0;       // 1.0 = FULL SPEED

  //-------------------- Nunchuk Initialization --------------------------//
  Wire.begin();
  nunchuk.init(); // initiated in loop as necissary

  delay(3000);    // Allows for the cart to turn on and wait until the system starts up
}

void loop()
{
  //------------------- start delay/ fix data-----------------------//
  if (initialStartCount == 0) 
  {
    for (int i = 0; i < 100; i++)
    {
      delay(10);
      readFront();
      printFront();
      Serial.println();
    }
    Serial.println("DONE");
    initialStartCount = 1;
  }

  //-------------------- System Off --------------------------//
  // rear power btn is pressed
  if (digitalRead(buttonTurnOnOff) == LOW)
  {
    if (DEBUG) Serial.println("SHUTTING DOWN");
    shutDown();
  }

  //------------------- Pwr ------------------------------------------//
  batteryLevel = readPower();
  if (DEBUG) Serial.print(readPower());
  // AS OF 6/28 460
  if(batteryLevel < 450)
  {
    analogWrite(PowerStrengthPin, 255); 
  }

  //------------------- Front Controllers --------------------------//
  readFront();
  
  //-------------------- Rear Controllers --------------------------//
  Serial.flush();
  readWii();
  Serial.flush();
  readAtari();
  Serial.flush(); 
  
  //-------------------- Print Controllers --------------------------//
  if (DEBUG) 
  {
    printFront();
    Serial.flush();
    printWii();
    Serial.flush();
    printAtari();
    Serial.flush();
    printMotorVals();
    Serial.flush();
    Serial.println();
  }

  //-------------------- Controller Signals --------------------------//
  seatControl();
  cartControl();   // Decides what to give the Motor Control, then gives it

  Serial1.print("MD: ");
  Serial1.print(driveVal / myFrontArray[2]);
  Serial1.print("\r\n");

  Serial1.print("MT: ");
  Serial1.print(turnVal / myFrontArray[2] / 2);
  Serial1.print("\r\n");

  //-------------------- Inactive Turn Off --------------------------//
  if (driveVal == 0 && turnVal == 0) driveInactive = true;

  else driveInactive = false;
  
  if (driveInactive == true && seatInactive == true)
  {
    if (inactiveCounter == 0)
    {
      loopTime = millis();
      inactiveCounter = 1;
    }
    if((millis() - loopTime) > 20000)
    {
      shutDown();
    }
  }
  else
  {
    inactiveCounter = 0;
    loopTime = millis();
  }
}

// Function to read and save the data that the Arduino Nano is sending from the front of the cart
// into myFrontArray.
void readFront()
{
  if (Serial3.available())
  {
    while (Serial3.available())
    {
      // Looks for the beginning of the string
      if (Serial3.read() == ':')
      {
        for (int i = 0; i < (SIZE); i++)
        {
          // Read the data if it is not a comma
          if (Serial3.peek() != ',')
          {
            myFrontArray[i] = Serial3.parseInt();
          }
          Serial3.read();     // Reads ','
        }
      }
      Serial3.read();         // Reads ':'
    }
  }
  else
  {
    if(DEBUG) Serial.println("--------------Unavailable------------");
    shutDown();
  }
}

// Function to read and save the various values from the rear Nunchuk. This function will reinitialize
// the Nunchuk if necessary. Otherwise it will save the corresponding values into myWiiArray.
void readWii()
{
  // If the Wii controller gets unplugged then plugged back in, reinitialize.
  if (Wire.requestFrom(0x52, 6) != 0)
  {
    nunchuk.init();
    if(DEBUG) Serial.println("init_-__--___---____----_____________");
    isWii = true;
  }
  else
  {
    isWii = false;
    myWiiArray[0] = 0;
    myWiiArray[1] = 0;
    myWiiArray[5] = 0;
    myWiiArray[6] = 0;
  }

  nunchuk.update();

  if (isWii == true)
  {
    int midPoint = 128;
    int range = 15;

    // Take the current X-Axis reading and convert it according to the midPoint and range values.
    signed int tempInt = nunchuk.analogX;
    tempInt = (tempInt > (midPoint + range) || tempInt < (midPoint - range)) ? tempInt : midPoint;
    myWiiArray[0] = map(tempInt, 26, 230, -2047, 2047); // Wii X-Axis

    // Take the current Y-Axis reading and convert it according to the midPoint and range values.
    tempInt = nunchuk.analogY;
    tempInt = (tempInt > (midPoint + range) || tempInt < (midPoint - range)) ? tempInt : midPoint;
    myWiiArray[1] = map(tempInt, 26, 230, -2047, 2047); // Wii Y-Axis

    myWiiArray[6] = (nunchuk.cButton); // Wii C button
    myWiiArray[5] = (nunchuk.zButton); // Wii Z button

    killSwitch = ((myWiiArray[5] == 0) ? false : true);
  }
}

// Function to read and process the various values from the rear Atari. This function will save the
// corresponding values into myWiiArray.
void readAtari()
{
  for (int i = 0; i < 5; i++)
  {
    myAtariArray[i] = digitalRead(i + 2);
  }

  int tempInt;
  tempInt = myAtariArray[0];
  myAtariArray[0] = map(tempInt, 1, 0, 0, 2047);
  tempInt = myAtariArray[1];
  myAtariArray[1] = map(tempInt, 1, 0, 0, -2047);
  tempInt = myAtariArray[2];
  myAtariArray[2] = map(tempInt, 1, 0, 0, -2047);
  tempInt = myAtariArray[3];
  myAtariArray[3] = map(tempInt, 1, 0, 0, 2047);

  // If the Nunchuk is not plugged in, assign killSwitch to the Atari button
  if (!isWii)
  {
    killSwitch = ((myAtariArray[4] == 1) ? false : true);
  }
}

//ReadPower
int readPower()
{
  return analogRead(BatPin);
}

//PrintPower
void printPwr()
{
  Serial.print("Pwr: " + batteryLevel);
}

// Function to print the values sent from the front Arduino Nano.
void printFront()
{
  Serial.print(" printFront(): ");
  for (int i = 0; i < SIZE; i++)
  {
    Serial.print(myFrontArray[i]);
    Serial.print(", ");
  }
}

// Function to print the values received from the back Nunchuk.
void printWii()
{
  // Wii Print
  Serial.print("  printWii(): ");
  Serial.print(myWiiArray[0], DEC);
  Serial.print(", ");
  Serial.print(myWiiArray[1], DEC);
  Serial.print(", ");
  Serial.print(myWiiArray[5], DEC);
  Serial.print(", ");
  Serial.print(myWiiArray[6], DEC);
  Serial.print(", ");
}

// Function to print the values received from the back Atari.
void printAtari()
{
  Serial.print("  printAtari(): ");
  for (int i = 0; i < 5; i++) {
    Serial.print(myAtariArray[i], DEC);
    Serial.print(", ");
  }
}

// Function to print the motor values that are assigned from cartControl().
void printMotorVals() 
{
  Serial.print("Turn: ");
  Serial.print(turnVal);
  Serial.print(",  Drive: ");
  Serial.print(driveVal);
}

// Function to control the raising and lowering of the seat. MyFrontArray[10] corresponds to lowering the seat while
// MyFrontArray[11] corresponds to raising the seat. If the seat is being lowered it will check to see the status of
// the limit switch as well, if that is active then it will stop the output of the motor controller.
void seatControl(void)
{
  // Raising of the seat
  if (myFrontArray[11] == 0)
  {
    digitalWrite(motorControlPWM, 100);
    digitalWrite(motorControlDIR, HIGH);
    delay(1);
    seatInactive = false;
  }

  // Lowering of the seat
  else if (myFrontArray[10] == 0)
  {
    // If limit switch is pressed then stop lowering the seat
    if (digitalRead(seatLimitSwitch) == 1)
    {
      digitalWrite(motorControlPWM, LOW);
      digitalWrite(motorControlDIR, LOW);
    }
    else
    {
      digitalWrite(motorControlPWM, 100);
      digitalWrite(motorControlDIR, LOW);
      delay(1);
    }
    seatInactive = false;
  }

  // Seat is inactive, stop raising/lowering it and set seatInactive to true
  else
  {
    digitalWrite(motorControlPWM, LOW);
    digitalWrite(motorControlDIR, LOW);
    delay(1);
    seatInactive = true;
  }
}

// Function that will control which joystick is used for controlling the motors.
// Precedence goes - rear Nunchuk > rear Atari > front Atari/Digital > front Analog
void cartControl()
{
  // If Z button on the Nunchuk or the button on Atari are pressed, shut off motors.
  if (killSwitch)
  {
    killMotor();
  }
  else
  {
    // If a Nunchuk is plugged in
    if (isWii)
    {
      // If Nunchuk is active use it's values
      if (myWiiArray[0] != 0 || myWiiArray[1] != 0)
      {
        driveVal  = myWiiArray[0];
        turnVal = myWiiArray[1];
      }
      // Else use the values from the front controllers.
      else
      {
        proccessFront();
      }
    }

    // If a Nunchuk is not plugged in
    else
    {
      // If rear Atari is not being used all will be 0
      int xVal1 = myAtariArray[2];
      int xVal2 = myAtariArray[3];
      int yVal1 = myAtariArray[0];
      int yVal2 = myAtariArray[1];

      // If one of the values is not 0, find out which one and assign that to the corresponding direction.
      if (xVal1 != 0 || xVal2 != 0 || yVal1 != 0 || yVal2 != 0)
      {
        driveVal = yVal1 + yVal2;
        turnVal = xVal1 + xVal2;
        atariActive = true;
      }

      // If Atari was active and now there is no input, set the turn and drive values to 0 and set Atari to inactive
      else if (atariActive == true)
      {
        turnVal = 0;
        driveVal = 0;
        atariActive = false;
      }

      // If there are no values from the Atari, use the values from the front controllers
      else
      {
        proccessFront();
      }
    }
  }
}

// Function that will be called if the parental override is not active. This function will then take the corresponding
// values from the Arduino Nano and then assign the driveVal and turnVal based on what controller is being used in front.
void proccessFront()
{

  int newCount = myFrontArray[13];
  if (myFrontArray[12] == 1)
  {
    Serial.println("----------------Shutdown Signal---------------");
    shutDown();
  }
  if (newCount == oldCount)
  {
    sameCount += 1;
  }
  else sameCount = 0;
  if (sameCount == 15)
  {
    Serial.println("----------------Coutn Shuutdown Signal---------------");
    shutDown();
  }

  oldCount = newCount;

  int xVal = 0;
  int yVal = 0;

  // If digital forward is not 0
  if (myFrontArray[3] != 0)
  {
    xVal = myFrontArray[3];
  }
  // Else if digital reverse is not 0
  else if (myFrontArray[4] != 0)
  {
    xVal = myFrontArray[4];
  }
  // Else assign xVal to 0,
  else
  {
    xVal = 0;
  }
  // If digital left is not 0
  if (myFrontArray[5] != 0)
  {
    yVal = myFrontArray[5];
  }
  // Else if digital right is not 0
  else if (myFrontArray[6] != 0)
  {
    yVal = myFrontArray[6];
  }
  // Else assign yVal to 0
  else
  {
    yVal = 0;
  }

  // If either of these values is not 0 then use the digital outputs to control the motors.
  if (xVal != 0 || yVal != 0)
  {
    turnVal  = xVal;
    driveVal = yVal;
  }

  // Otherwise use the analog outputs to control the motors.
  else
  {
    driveVal = myFrontArray[0];
    turnVal  = myFrontArray[1];
  }
}

// Function to stop the motors if the button on the joystick is pressed.
void killMotor()
{
  turnVal  = 0;
  driveVal = 0;
}

// Function that when called turns off systemStartPin which turns off the entire system.
void shutDown()
{
  if (DEBUG)Serial.println("----------------ShutDown from Here----");
  digitalWrite(systemStartPin, LOW);
}
